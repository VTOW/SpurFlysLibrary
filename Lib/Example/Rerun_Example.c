#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_mm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Mod_Vex_Comp_Control.c"

#define armPID(fInput) (fInput - ((SensorValue[I2C_1] + SensorValue[I2C_2]) / 2)) * 0.7

int autonomous1[150][3] = {
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0},
{0, 0, 0}};

void
tank (int iSpeedL, int iSpeedR) {
	motorSet(port3, iSpeedR);
	motorSet(port4, iSpeedR);
	motorSet(port5, iSpeedR);
	motorSet(port6, iSpeedL);
	motorSet(port7, iSpeedL);
	motorSet(port8, iSpeedL);
}

void
arm (int iSpeed) {
	motorSet(port1,  iSpeed);
	motorSet(port2,  iSpeed);
	motorSet(port9,  iSpeed);
	motorSet(port10, iSpeed);
}

int iDes;
void
armControl (bool bBtnReset, bool bSpeedBoost, bool bPreset, bool bBtnUp, bool bBtnDown) {
	int iOutput;
	if (bBtnUp || bBtnDown) {
		iOutput = bSpeedBoost ? (bBtnUp - bBtnDown) * 127 : (bBtnUp - bBtnDown) * 70;
		iDes = (SensorValue[I2C_1] + -SensorValue[I2C_2]) / 2;
	} else if (bPreset) {
		iOutput = armPID(250);
		iDes = (SensorValue[I2C_1] + -SensorValue[I2C_2]) / 2;
	} else {
		iOutput = armPID(iDes);
	}
	arm (iOutput);

	if (bBtnReset) clearAllIME();
}

void
initIO () {
	setAllMotor393();

	motorSetup(port1,  true);
	motorSetup(port2,  false);
	motorSetup(port3,  true,  LINESPEED);
	motorSetup(port4,  false, LINESPEED);
	motorSetup(port5,  false, LINESPEED);
	motorSetup(port6,  true,  LINESPEED);
	motorSetup(port7,  true,  LINESPEED);
	motorSetup(port8,  true,  LINESPEED);
	motorSetup(port9,  true);
	motorSetup(port10, false);

	sTeam = "HORNET ~ 21S";
	bLCDAuton =
	bLCDUserControl =  true;
}

void
pre_auton () {
	clearAllIME();
}

void
replay1 () {
	for (int i = 0; i < 150; i++) {
		arm (armPID(autonomous1[i][0]));
		tank (autonomous1[i][2], autonomous1[i][1]);
		delay(100);
	}
}

task
autonomous () {
	replay1();
}

task
usercontrol () {
	while (true) {
		tank ((vexRT[Ch3]), (vexRT[Ch2]));
		armControl (vexRT[Btn8D], vexRT[Btn6D], vexRT[Btn5D], vexRT[Btn6U], vexRT[Btn5U]);
		
		if (vexRT[Btn7D]) {
			waitForReleased7D();
			startTask(record);
		}
	}
}
